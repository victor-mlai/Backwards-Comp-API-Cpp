<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>BC API tricks</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">BC API tricks</h1>
</header>
<h1 id="how-to-make-c-api-changes-backwards-compatible">How to make C++
API changes Backwards Compatible</h1>
<p>I made this project to showcase some “tricks” on how to make
backwards compatible API changes. (E.g. renaming files, types, changing
parameter types, the return type, default parameters, an enum to
<code>enum class</code> etc.)</p>
<p>I added some tests (in /tests) to ensure that these tricks are indeed
backwards compatible.</p>
<p>There are also negative tests (see /neg-tests) to showcase some rare
cases where the API change breaks code that previously compiled.</p>
<h1 id="contributing">Contributing</h1>
<p>This project just got created.</p>
<p>Please feel free to create Issues and Pull Requests to improve this
list.</p>
<h1 id="warning">Warning</h1>
<p>These tricks assume the users of the library API don’t rely on ABI
compatibility as well, or use forward declarations or function pointers
(since, in general, they shouldn’t do so with foreign types unless
explicitly pointed out by the library).</p>
<h1 id="project-internals">Project internals</h1>
<p>/some_unstable_lib contains a header file for each API change in the
list further down. Each header exposes both the old API and the changed
API based on the <code>BC_API_CHANGED</code> macro.</p>
<p>/tests represents the users of the library whose code must compile
before and after the API change.</p>
<p>/neg-tests contains code that should not compile after the API
change.</p>
<p>.github/workflows/deploy.yml updates Github Pages with the new
changes from this README.</p>
<p>.github/workflows/cmake.yml checks if the tests in /tests compile
with the macro <code>BC_API_CHANGED</code> OFF (before the API change)
and ON (after). It also checks that the negative tests compile before
the API change, and <strong>don’t</strong> compile after.</p>
<h1 id="overview">Overview</h1>
<ul>
<li><a href="#mv_namespace">Rename a namespace</a></li>
<li><a href="#mv_type">Rename a type</a></li>
<li><a href="#mv_header">Rename a header</a></li>
<li><a href="#change_defaults">Change default parameters</a></li>
<li><a href="#change_ret_type">Change the return type</a></li>
<li><a href="#change_to_enum_class">Change old-style enum to enum
class</a></li>
<li><a href="#reasonably_safe_changes">Reasonably safe changes</a> <!--
* [Move symbols to a different namespace](#move_symb_to_ns)
* [Move symbols to a different class](#move_symb_to_class)
--></li>
</ul>
<h1 id="how-to">How to:</h1>
<p><a id="mv_namespace"></a></p>
<h2 id="rename-a-namespace">Rename a namespace</h2>
<h3 id="initial-code">Initial code:</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> path<span class="op">::</span>to<span class="op">::</span>v1 <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<h3 id="scenario">Scenario:</h3>
<p>We maybe need to change the namespace name to fix a typo. We will
change it from <code>path::to::v1</code> to
<code>path::to::v2</code>.</p>
<h3 id="solution">Solution:</h3>
<p>Rename the old namespace to the new one and add a namespace alias for
the old one.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="va">+ namespace path::to::v2 {}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ namespace path::to {</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="va">+   namespace v1 = path::to::v2;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="va">+ }</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="va">+ </span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="st">- namespace path::to::v1 { ... }</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="va">+ namespace path::to::v2 { ... }</span></span></code></pre></div>
<h3 id="remarks">Remarks:</h3>
<ul>
<li><p><code>[[deprecated]]</code> attribute doesn’t work on namespace
aliases. You can try compiler specific directives (Eg.
<code>#pragma deprecated(keyword)</code> for msvc)</p></li>
<li><p>The empty namespace <code>namespace path::to::v2 {}</code> was
added at the top of the file for visibility purposes</p></li>
</ul>
<h3 id="relevant-files">Relevant Files:</h3>
<ul>
<li>API: <a
href="some_unstable_lib/include/NamespaceRename.hpp">NamespaceRename.hpp</a></li>
<li>User: <a
href="tests/NamespaceRenameTest.cpp">NamespaceRenameTest.cpp</a></li>
</ul>
<p><a id="mv_type"></a></p>
<h2 id="rename-a-type">Rename a type</h2>
<h3 id="initial-code-1">Initial code:</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> OldName <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span></code></pre></div>
<h3 id="scenario-1">Scenario:</h3>
<p>We maybe need to update the struct name to fix a typo. We will change
it to <code>NewName</code>.</p>
<h3 id="solution-1">Solution:</h3>
<p>We can use a type alias.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="st">- struct OldName { ... };</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ struct NewName { ... };</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="va">+ using OldName = NewName;</span></span></code></pre></div>
<h3 id="remarks-1">Remarks:</h3>
<ul>
<li>You can deprecate the old <code>OldName</code>.</li>
<li>The users might learn the hard way that they shouldn’t forward
declare foreign types.</li>
</ul>
<h3 id="relevant-files-1">Relevant Files:</h3>
<ul>
<li>API: <a
href="some_unstable_lib/include/StructRename.hpp">StructRename.hpp</a></li>
<li>User: <a
href="tests/StructRenameTest.cpp">StructRenameTest.cpp</a></li>
</ul>
<p><a id="mv_header"></a></p>
<h2 id="rename-a-header">Rename a header</h2>
<h3 id="initial-code-2">Initial code:</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// v1/OldName.hpp:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<h3 id="scenario-2">Scenario:</h3>
<p>We need to rename the header to <code>v2/NewName.hpp</code>.</p>
<h3 id="solution-2">Solution:</h3>
<ol type="1">
<li>Rename the header:</li>
</ol>
<div class="sourceCode" id="cb6"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="st">- // v1/OldName.hpp:</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ // v2/NewName.hpp:</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
<ol start="2" type="1">
<li>Create a compatibility header file in the old location that includes
the renamed one.</li>
</ol>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// v1/OldName.hpp: &lt;- created to only include the renamed header + deprecation notice</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;v2/NewName.hpp&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">// You can also deprecate it by inserting a compilation warning:</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">// #warning OldName.hpp is deprecated, include &quot;v2/NewName.hpp&quot;.`</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Don&#39;t use #error since there is no way for users to silence it.</span></span></code></pre></div>
<h3 id="remarks-2">Remarks:</h3>
<p>Rename using your versioning tool (Git/SVN) so you don’t lose blame
history. For Git, do the change 2 steps in 2 different commits.</p>
<p><a id="change_defaults"></a></p>
<h2 id="change-default-parameters">Change default parameters</h2>
<h3 id="initial-code-3">Initial code:</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> SomeMethod<span class="op">(</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mandatory<span class="op">,</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> opt1 <span class="op">=</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> opt2 <span class="op">=</span> <span class="fl">1e-6</span><span class="bu">f</span><span class="op">,</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> opt3 <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<h3 id="scenario-3">Scenario:</h3>
<p>This method receives too many default parameters, and it only becomes
harder for users to call it with only 1 or 2 parameters changed. We need
to change the method to receive a struct containing these parameters
instead.</p>
<h3 id="solution-3">Solution:</h3>
<p>If you would just overload <code>SomeMethod</code> with the default
parameters changed, users calling <code>SomeMethod</code> with just the
mandatory parameters will now have the compiler complain about ambiguity
(that it doesn’t know which of the 2 methods to call).</p>
<p>To tell the compiler to prefer the newer method we need to make the
old one less specialized by making it a template.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="va">+ template&lt;int = 0&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>void SomeMethod(</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    int mandatory,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    bool opt1 = false,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    float opt2 = 1e-6f,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    int opt3 = 42</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="va">+ ) {</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="va">+  // Call the new implementation now</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="va">+  SomeMethod(mandatory, SomeMethodOpts{opt1, opt2, opt3});</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="va">+ }</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="va">+ </span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="va">+ struct SomeMethodOpts { bool opt1 = false; float opt2 = 1e-6; int opt3 = 42; };</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="va">+ void SomeMethod(</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="va">+     int mandatory,</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="va">+     SomeMethodOpts opts = {}</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>) { ... }</span></code></pre></div>
<h3 id="remarks-3">Remarks:</h3>
<ul>
<li>You can deprecate the old <code>SomeMethod</code> (now a
template)</li>
<li>If the definition needs to be in the .cpp file, and the function is
dll exported, you need to explicitly instantiate the templated
<code>SomeMethod</code> in the .cpp file</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> DLL_EXPORT <span class="dt">void</span> SomeMethod<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mandatory<span class="op">,</span> <span class="dt">bool</span> opt1 <span class="op">=</span> <span class="kw">false</span><span class="op">,</span> <span class="dt">float</span> opt2 <span class="op">=</span> <span class="fl">1e-6</span><span class="bu">f</span><span class="op">,</span> <span class="dt">int</span> opt3 <span class="op">=</span> <span class="dv">42</span><span class="op">);</span></span></code></pre></div>
<h3 id="relevant-files-2">Relevant Files:</h3>
<ul>
<li>API: <a
href="some_unstable_lib/include/MethodDefaultParams.hpp">MethodDefaultParams.hpp</a></li>
<li>User: <a
href="tests/MethodDefaultParamsTest.cpp">MethodDefaultParamsTest.cpp</a></li>
</ul>
<p><a id="change_ret_type"></a></p>
<h2 id="change-the-return-type">Change the return type</h2>
<h3 id="warning-1">Warning:</h3>
<p>Prefer to just add a new method called slightly different instead.
What’s about to follow is over-engineered.</p>
<p>In short: we will overload the implicit cast operator of the new
return type, and if the return type needs to be a primitive, we will
create a new wrapper class.</p>
<h3 id="initial-code-4">Initial code:</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// (1) change some primitive `T` to `NewUserDefT`</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> CheckPassword<span class="op">(</span><span class="bu">std::</span>string<span class="op">);</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">// (2) change some primitive `const T&amp;` to primitive `T`</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Strukt <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">float</span><span class="op">&amp;</span> GetMemF<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_memF</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> <span class="va">m_memF</span><span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="scenario-4">Scenario:</h3>
<ol type="1">
<li><p><code>CheckPassword</code> method returns true if it succeeds,
otherwise false. Make this method return some meaningful error message
so the user knows why it failed (why it returned false).</p></li>
<li><p><code>Strukt::GetMemF</code> returns a primitive type as
const&amp; which is bad for multiple reasons (performance, <a
href="https://www.sandordargo.com/blog/2020/11/18/when-use-const-3-return-types#returning-const-references">lifetime</a>,
complexity issues). We need to return by value.</p></li>
</ol>
<p>Unfortunately, we cannot just overload a function by return type and
then deprecate it.</p>
<h3 id="solution-4">Solution:</h3>
<p>For situation (1): Add <code>operator bool()</code> so that the new
type can be implicitly casted to <code>bool</code>.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>// (1) change primitive `T` to `NewUserDefT`</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ struct CheckPasswordResult { // mimics std::expected&lt;void, std::string&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="va">+     operator bool() const { return !m_errMsg.has_value(); }</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="va">+     const std::string&amp; error() const { return m_errMsg.value(); }</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="va">+ private:</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="va">+     std::optional&lt;std::string&gt; m_errMsg;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="va">+ };</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="st">- bool CheckPassword(std::string);</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="va">+ CheckPasswordResult CheckPassword(std::string);</span></span></code></pre></div>
<ul>
<li>(1.1): If you want to take it a step further, and allow implicit
casts only to <code>bool</code>, since C++20 you can make the cast
operator conditionally explicit (In the tests,
<code>int x = CheckPassword("");</code> doesn’t compile after the API
change, while <code>bool x = CheckPassword("");</code> does. See <a
href="neg-tests/ReturnTypeChangeTest.cpp">neg-tests/ReturnTypeChangeTest.cpp</a>)</li>
</ul>
<p>For situation (2): Add a new class <code>GetterRetT</code> with 2
implicit cast operators to <code>NewRetT</code> and to
<code>OldRetT</code>. “Mark” the implicit cast operator to
<code>OldRetT</code> as deprecated and as “less specialized” (i.e. as
template, so that the compiler will choose at “overload resolution” the
<code>NewRetT</code> overload).</p>
<p>Additionally, inside the <code>Strukt</code> return
<code>GetterRetT</code> by <code>const&amp;</code> so that we avoid
runtime exceptions from dangling references in user’s code in case they
have a StruktWrapper class that also has a
<code>const float&amp; GetMemF()</code> that called and returned the
result of our <code>GetMemF()</code>.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>// (2) change primitive `const T&amp;` to primitive `T`</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ struct GetterRetT {</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="va">+   template &lt;int = 0&gt; // (2.1)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="va">+   operator OldRetT () const { ... }</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="va">+   operator NewRetT () const { ... }</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="va">+ };</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>struct Strukt {</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="st">-   const float&amp; GetMemF() const { return m_memF; }</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="va">+   const GetterRetT&amp; GetMemF() const { return m_memF; }</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>private:</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="st">-   float m_memF = 3.f;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="va">+   GetterRetT m_memF = 3.f;</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<h3 id="relevant-files-3">Relevant Files:</h3>
<ul>
<li>API: <a
href="some_unstable_lib/include/ReturnTypeChange.hpp">include/ReturnTypeChange.hpp</a>
<a
href="some_unstable_lib/include/ReturnTypeChangeByValue.hpp">include/ReturnTypeChangeByValue.hpp</a></li>
<li>User: <a
href="tests/ReturnTypeChangeTest.cpp">tests/ReturnTypeChangeTest.cpp</a>
<a
href="tests/ReturnTypeChangeByValueTest.hpp">tests/ReturnTypeChangeByValueTest.hpp</a></li>
<li>Neg: <a
href="neg-tests/ReturnTypeChangeTest.cpp">neg-tests/ReturnTypeChangeTest.cpp</a></li>
</ul>
<p><a id="change_to_enum_class"></a></p>
<h2 id="change-old-style-enum-to-enum-class">Change old-style enum to
enum class</h2>
<h3 id="warning-2">Warning:</h3>
<p>Changing the enum to enum class will inherently breaks implicit
conversions to integers (e.g. when the enum is used as bit flags:
<code>STYLE_BOLD | STYLE_ITALLIC</code> results in a
<code>int</code>).</p>
<h3 id="initial-code-5">Initial code:</h3>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Style <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    STYLE_BOLD<span class="op">,</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    STYLE_ITALLIC<span class="op">,</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    STYLE_STRIKE_THROUGH<span class="op">,</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="scenario-5">Scenario:</h3>
<p>We need to modernize the API to use <code>enum class</code>
instead.</p>
<h3 id="solution-5">Solution:</h3>
<p>In order to not break scoped uses of the enum
(e.g. <code>auto style = Style::STYLE_BOLD</code>) we will duplicate the
enum fields with the enum class’s naming style, and make sure their
value is assigned to the old enum fields.</p>
<p>In order to not break unscoped uses of the enum
(e.g. <code>auto style = STYLE_BOLD</code>), we will define static
variables for each enum entry.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="st">- enum Style {</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ enum class Style {</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="va">+   Bold,</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="va">+   Itallic,</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="va">+   StrikeThrough,</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="st">-   STYLE_BOLD,</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="st">-   STYLE_ITALLIC,</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="st">-   STYLE_STRIKE_THROUGH,</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="va">+   STYLE_BOLD = Bold,</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="va">+   STYLE_ITALLIC = Itallic,</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="va">+   STYLE_STRIKE_THROUGH = StrikeThrough,</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="va">+ static inline Style STYLE_BOLD = Style::Bold;</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="va">+ static inline Style STYLE_ITALLIC = Style::Itallic;</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="va">+ static inline Style STYLE_STRIKE_THROUGH = Style::StrikeThrough;</span></span></code></pre></div>
<h3 id="remarks-4">Remarks:</h3>
<ul>
<li><p>Inspired by the <a
href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0439r0.html">memory_order
change in the standard</a></p></li>
<li><p>If the enum was used as bit flags, define bitwise operators as
well. And if there were methods that recieved the unscoped enum as
<code>int</code>, overload them to receive the scoped enum now (since
the bitwise operators return the scoped enum, if they were to return an
<code>int</code>, users will not be able to chain more than 2 of them:
e.g.
<code>Print(STYLE_BOLD | STYLE_ITALLIC | STYLE_STRIKE_THROUGH) // operator|(Style, int) is not overloaded</code>).</p></li>
</ul>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Add `friend` if the enum lies inside a `struct`</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">[</span><span class="kw">friend</span><span class="op">]</span> <span class="kw">inline</span> Style <span class="kw">operator</span><span class="op">|(</span>Style lhs<span class="op">,</span> Style rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span>Style<span class="op">&gt;(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>lhs<span class="op">)</span> <span class="op">|</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>rhs<span class="op">));</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="relevant-files-4">Relevant Files:</h3>
<ul>
<li>API: <a
href="some_unstable_lib/include/ChangeToEnumClass.hpp">ChangeToEnumClass.hpp</a></li>
<li>User: <a
href="tests/ChangeToEnumClassTest.cpp">ChangeToEnumClassTest.cpp</a></li>
</ul>
<!--

<a id="move_symb_to_ns"></a>

## Move types/symbols to a different namespace

### Initial code:

```cpp
namespace path::to::v1 {
  struct DontMove {};
  struct Bar {};
  constexpr int VAL = 42;
  enum SomeEnum { A, B, C };
}
```

### Scenario:

### Solution:

```cpp
// simply move them
namespace path::to::v2 {
struct Bar {
};
constexpr int VAL = 42;
enum SomeEnum { A, B, C };
}

namespace path::to::v1 {
struct DontMove {
};

// add using declarations for each
// moved symbol in the old namespace
using path::to::v2::Bar;
using path::to::v2::VAL;
using path::to::v2::SomeEnum;
// to not break "v2::A" uses
using path::to::v2::SomeEnum::A;
using path::to::v2::SomeEnum::B;
using path::to::v2::SomeEnum::C;
}
```

### Remarks:

### Relevant Files:


<a id="move_symb_to_class"></a>

## Move types/symbols to a different class

### Initial code:

```cpp
// Change: move these to NewClass
struct OldClass {
struct Bar {
};
constexpr int VAL = 42;
enum SomeEnum { A, B, C };
bool Foo() { return true; }
}
```

### Solution:

```cpp
// simply move them
struct NewClass {
struct Bar {
};
static constexpr int VAL = 42;
enum SomeEnum { A, B, C };
bool Foo() { return true; }
}

// In short, the old class should depend on the new one so you can add these:
struct OldClass {
using Bar = NewClass::Bar;
static constexpr int VAL = NewClass::VAL;
using SomeEnum = NewClass::SomeEnum;
// plain old enums are special, you also need to not break "OldClass::A" uses
static constexpr SomeEnum A = NewClass::A;
static constexpr SomeEnum B = NewClass::B;
static constexpr SomeEnum C = NewClass::C;

bool Foo() { return m_newCls.Foo(); }
private:
NewClass m_newCls;
}
```

### Remarks:

You need to add a `static constexpr` for each enum field since it
is unscoped in the old class.
-->
<p><a id="reasonably_safe_changes"></a></p>
<h2 id="other-reasonably-safe-changes">Other reasonably safe
changes:</h2>
<ul>
<li>Adding <code>const</code> to a member function
(<code>T Get();</code> -&gt; <code>T Get() const;</code>)</li>
<li>Making a member function <code>static</code>
(<code>T Get() const;</code> -&gt; <code>static T Get();</code>)
<ul>
<li>the code <code>obj.Get(..)</code> will still compile.</li>
</ul></li>
<li>Adding <code>[[nodiscard]]</code>
(<code>[[nodiscard]] int Get()</code> or
<code>class [[nodiscard]] Result</code>)
<ul>
<li>should not be added to any random class or methods that have side
effects (the user might have called the method for its side
effectes)</li>
</ul></li>
<li>Adding <code>explicit</code> to a constructor with only 1 parameter.
<ul>
<li>except for classes that are expected to be implicitly constructed
from that 1 parameter.</li>
</ul></li>
<li>Removing the <code>const&amp;</code> when passing a copyable
parameter (<code>void Set(const T&amp;);</code> -&gt;
<code>void Set(T);</code>)
<ul>
<li>e.g. cannot remove <code>const&amp;</code> from
<code>void Set(const std::unique_ptr&lt;T&gt;&amp;);</code> since
unique_ptr is not copyable</li>
</ul></li>
<li>Removing the <code>const</code> when returning by value:
<code>const RetT Get()</code>
<ul>
<li>except from non-private virtual methods, since the user’s derived
class might overide them.</li>
<li>this change can break some rare cases (see <a
href="neg-tests/RemoveConstReturnByValueTest.cpp">neg-tests/RemoveConstReturnByValueTest.cpp</a>):
<ul>
<li><code>auto&amp; val = Get();</code> was valid code until we removed
the <code>const</code></li>
<li>the return type was passed directly to a method with 2 overloads
<code>Foo(const RetT&amp;)</code> to <code>Foo(RetT&amp;)</code>, it now
calls the non-const one.</li>
<li>if <code>Get</code> returns <code>Base</code> now by value and
<code>Derived</code> has an implicit constructor from <code>Base</code>,
you can get incompatible types in ternary operators:
<code>cond ? const Derived : Base</code>
(<code>cond ? Derived{} : Get();</code>)</li>
</ul></li>
</ul></li>
<li>Converting a class that has only static methods to a namespace
<ul>
<li>make sure the constructors and operator= are private, otherwise
deprecate them before changing the class to a namespace</li>
</ul></li>
<li>Changing the underlying type of an enum (e.g. from
<code>enum Flags</code> to <code>enum Flags: uint64_t</code>, which
happens when the enum is used as bit flags and we need to add another
entry after <code>1&lt;&lt;31</code>)
<ul>
<li>except if users depend on sizeof(Flags), e.g. if they serialize it
to binary data</li>
<li><code>int x = Flags::X</code>, where <code>X=1&lt;&lt;31</code>,
will still compile and it will not overflow, even if <code>Flags</code>
is now of type <code>uint64_T</code>, since the compiler sees that the
value of <code>X</code> still fits inside <code>int</code></li>
<li>users will get warnings if they compile with
<code>-Wconversion</code> and assign a value of type <code>Flags</code>
into a now narrower type like an <code>int</code></li>
</ul></li>
</ul>
<h2 id="todos">TODOs</h2>
<ul>
<li>Add tests to ensure no breakings for dynamic libraries. (So we check
ODR violations as well)</li>
<li>Change a base class by making the new one extend from the old
one</li>
<li>…</li>
</ul>
</body>
</html>
